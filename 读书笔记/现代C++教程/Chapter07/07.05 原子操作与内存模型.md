
关键字：`std::atomic`，`std::atomic<T>::is_lock_free`

----

#### 原子操作

因为CPU的乱序执行特性，在未定义行为的代码中可能会导致输出不是期望值，因此引入了原子操作。虽然 `std::mutex` 能够解决上面的并发读写问题，但是这种方式是一个 **系统级** 的功能，最终生成的CPU指令会非常多，现代C++提供了CPU指令 **原子级** 的操作。

C++11提供了两个自增自减操作：`fetch_add, fetch_sub`

```cpp
std::atomic<int> count = {0};

int main(){
    std::thread t1([](){
        count.fetch_add(1);
    });

    std::thread t2([](){
        count++;         // 等价于 fetch_add
        count += 1;      // 等价于 fetch_add
    });

    t1.join();
    t2.join();
    std::cout << count << std::endl;

    return 0;
};
```

【注意】并非所有的类型都提供原子操作，因为原子操作的可行性取决于CPU架构以及所实例化结构是否满足该架构对内存对齐的要求，可以通过 `std::atomic<T>::is_lock_free` 来检查原子类型是否支持原子操作：

```cpp
struct A{
    float x;
    int y;
    long long z;
};

int main(){
    std::atomic<A> a;
    std::cout  << std::boolalpha << a.is_lock_free() << std::endl;

    return 0;
};
```

---

#### 一致性模型

并行执行多个线程可以粗略视为一种分布式系统，在分布式系统中任何通讯甚至是本地通讯都需要消耗一定时间。

如果强行将一个变量 `v` 在多个线程之间的操作设置为原子操作，即任何一个线程在操作完 `v` 后，其他线程均能同步感知到 `v` 的变化，对于变量 `v` 而言表现为顺序执行的程序，如果削弱原子操作的进程同步条件就能适当加速。

从原理上看